Hacking
=======

Build
-----
Uses the GNU autotools.  Run `autogen -i`; `mkdir build`; `cd build`;
`../configure --prefix=$PWD/install`; `make`.

Layout
------
Headers are mixed with implementation.  Code is platform-agnistic,
except for the innermost functions which are defined in independent
code and implemented under platforms/.  Implementations favour a cheap
embedded implementation.

lib/
 - common library functions

platform/
 - platform specific implementations

experiments/
 - small experiments made along the way

external/
 - third party libraries

Style
-----
Uses C++11, GCC extensions, and binutils features to make the code
easier to read and maintain.

Product specific behaviour is done by implementing functions in the
common classes.  The functions are normally wired together in a
product specific file.

For example, Timer::dispatch() is called when a timer expires.  The
platform wiring implements Timer::dispatch() to call
Switcher::trigger() with the platform specific timer callback ID.  The
wiring also implements Switcher::dispatch() which calls the event
handler.

Hardware interface
------------------
Events are generated by the HAL, timers, and other functions.  Events
are recorded in a Switcher and then dispatched in priority order.
Event handlers are short and run to completion.

Status
------
Always out of date, but still.

STM32:

* Basic startup
* System tick driver
* GPIO driver
* USART driver (for GPS)
* PWM input driver (for reading the receiver demands)
* PWM output driver (for driving the servo)
* USB ACM driver
* Watchdog driver
* Serial log based debugging

roverif:

* Application level timers
* Switcher for dispatching events
* Status LED
* Supervisor
* Fail safe configuration
* Software fault fail safe
* GPS driver
* Accelerometer driver
* Gyro driver
